import { NextRequest, NextResponse } from 'next/server';
import { readFileSync } from 'fs';
import { join } from 'path';

// Cache for loaded data
let exploitsCache: any[] | null = null;
let statsCache: any | null = null;

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '50');
    const search = searchParams.get('search') || '';
    const category = searchParams.get('category') || '';
    const author = searchParams.get('author') || '';
    const cve = searchParams.get('cve') || '';
    const year = searchParams.get('year') || '';
    const sortBy = searchParams.get('sortBy') || 'id';
    const sortOrder = searchParams.get('sortOrder') || 'desc';

    // Load data only once and cache it
    if (!exploitsCache) {
      const dataPath = join(process.cwd(), 'public', 'data', 'exploits.json');
      exploitsCache = JSON.parse(readFileSync(dataPath, 'utf8'));
    }

    if (!statsCache) {
      const statsPath = join(process.cwd(), 'public', 'data', 'stats.json');
      statsCache = JSON.parse(readFileSync(statsPath, 'utf8'));
    }

    let filteredExploits = [...exploitsCache];

    // Apply filters
    if (search) {
      const searchLower = search.toLowerCase();
      filteredExploits = filteredExploits.filter(exploit =>
        exploit.title.toLowerCase().includes(searchLower) ||
        exploit.author.toLowerCase().includes(searchLower) ||
        exploit.content.toLowerCase().includes(searchLower) ||
        exploit.cves.some((cve: string) => cve.toLowerCase().includes(searchLower)) ||
        (exploit.cve_id && exploit.cve_id.toLowerCase().includes(searchLower))
      );
    }

    if (category) {
      filteredExploits = filteredExploits.filter(exploit => exploit.category === category);
    }

    if (author) {
      filteredExploits = filteredExploits.filter(exploit => exploit.author === author);
    }

    if (cve) {
      const cveLower = cve.toLowerCase();
      filteredExploits = filteredExploits.filter(exploit =>
        exploit.cves.some((c: string) => c.toLowerCase().includes(cveLower)) ||
        (exploit.cve_id && exploit.cve_id.toLowerCase().includes(cveLower))
      );
    }

    if (year) {
      filteredExploits = filteredExploits.filter(exploit =>
        exploit.date && exploit.date.includes(year)
      );
    }

    // Apply sorting
    filteredExploits.sort((a, b) => {
      let aVal = a[sortBy as keyof typeof a];
      let bVal = b[sortBy as keyof typeof b];

      if (aVal === null || aVal === undefined) aVal = '';
      if (bVal === null || bVal === undefined) bVal = '';

      if (typeof aVal === 'string' && typeof bVal === 'string') {
        aVal = aVal.toLowerCase();
        bVal = bVal.toLowerCase();
      }

      if (aVal < bVal) return sortOrder === 'asc' ? -1 : 1;
      if (aVal > bVal) return sortOrder === 'asc' ? 1 : -1;
      return 0;
    });

    // Calculate pagination
    const totalItems = filteredExploits.length;
    const totalPages = Math.ceil(totalItems / limit);
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + limit;
    const paginatedExploits = filteredExploits.slice(startIndex, endIndex);

    return NextResponse.json({
      data: paginatedExploits,
      pagination: {
        page,
        limit,
        totalItems,
        totalPages,
        hasNext: page < totalPages,
        hasPrev: page > 1
      },
      stats: statsCache
    });

  } catch (error) {
    console.error('API Error:', error);
    return NextResponse.json(
      { error: 'Failed to load exploits' },
      { status: 500 }
    );
  }
}
