'use client';

import { useState, useEffect, useCallback } from 'react';
import { Exploit, ArchiveStats, SearchFilters } from '@/lib/types';

interface UseExploitsResult {
  exploits: Exploit[];
  stats: ArchiveStats | null;
  loading: boolean;
  error: string | null;
  pagination: {
    page: number;
    totalPages: number;
    totalItems: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
  refetch: () => void;
  setPage: (page: number) => void;
  setFilters: (filters: SearchFilters) => void;
  setSorting: (sortBy: keyof Exploit, sortOrder: 'asc' | 'desc') => void;
}

interface ApiResponse {
  data: Exploit[];
  pagination: {
    page: number;
    limit: number;
    totalItems: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
  stats: ArchiveStats;
}

export function useExploits(initialFilters: SearchFilters = {
  query: '',
  category: '',
  author: '',
  cve: '',
  year: ''
}) {
  const [exploits, setExploits] = useState<Exploit[]>([]);
  const [stats, setStats] = useState<ArchiveStats | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [filters, setFilters] = useState<SearchFilters>(initialFilters);
  const [sortBy, setSortBy] = useState<keyof Exploit>('id');
  const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>('desc');
  const [page, setPage] = useState(1);

  const fetchExploits = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const params = new URLSearchParams({
        page: page.toString(),
        limit: '50',
        search: filters.query,
        category: filters.category,
        author: filters.author,
        cve: filters.cve,
        year: filters.year,
        sortBy: sortBy.toString(),
        sortOrder
      });

      const response = await fetch(`/api/exploits?${params}`);
      
      if (!response.ok) {
        throw new Error('Failed to fetch exploits');
      }

      const data: ApiResponse = await response.json();
      
      setExploits(data.data);
      setStats(data.stats);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred');
    } finally {
      setLoading(false);
    }
  }, [page, filters, sortBy, sortOrder]);

  useEffect(() => {
    fetchExploits();
  }, [fetchExploits]);

  const refetch = useCallback(() => {
    fetchExploits();
  }, [fetchExploits]);

  const handleSetPage = useCallback((newPage: number) => {
    setPage(newPage);
  }, []);

  const handleSetFilters = useCallback((newFilters: SearchFilters) => {
    setFilters(newFilters);
    setPage(1); // Reset to first page when filters change
  }, []);

  const handleSetSorting = useCallback((newSortBy: keyof Exploit, newSortOrder: 'asc' | 'desc') => {
    setSortBy(newSortBy);
    setSortOrder(newSortOrder);
    setPage(1); // Reset to first page when sorting changes
  }, []);

  return {
    exploits,
    stats,
    loading,
    error,
    pagination: {
      page,
      totalPages: Math.ceil((stats?.total_exploits || 0) / 50),
      totalItems: stats?.total_exploits || 0,
      hasNext: page < Math.ceil((stats?.total_exploits || 0) / 50),
      hasPrev: page > 1
    },
    refetch,
    setPage: handleSetPage,
    setFilters: handleSetFilters,
    setSorting: handleSetSorting
  };
}
